---
title: "xu34_35"
output: html_document
---

## Load all packages
```{r}

library("rlang")
library("Seurat");
library("sctransform");
library("dplyr");
library("RColorBrewer");
library("ggthemes");
library("ggplot2");
library("cowplot");
library("data.table");
library("scales")

```


## Set up Seurat object
```{r}
## Find the origial CR path

setwd("C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu34_bif3")

setwd("C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu35_bif3")

## Read in the feature-barcode matrices generated by the cellranger pipeline.

memory.limit(size=50000000)

samples=c("xu34","xu35")

data.10x = list()

data.10x[[1]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu34_bif3/raw_feature_bc_matrix");

data.10x[[2]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu35_bif3/raw_feature_bc_matrix");

setwd("C:/Users/Xiaosa Xu/Desktop/SC Stem Cell Manuscript/Seurat_sc_datasets/6_bif3_xu34_35")

## Convert each feature-barcode matrix to a Seurat object.

bif3.list = list(); # First create an empty list to hold the Seurat objects

bif3.list[[1]] = CreateSeuratObject(counts = data.10x[[1]], min.cells=3, min.features=200, project=samples[1]);

bif3.list[[1]][["DataSet"]] = samples[1];

bif3.list[[2]] = CreateSeuratObject(counts = data.10x[[2]], min.cells=3, min.features=200, project=samples[2]);

bif3.list[[2]][["DataSet"]] = samples[2];


## Optional, remove the raw data to save space:

rm(data.10x);


### Subset each library before merge or integrate


bif3.list[[1]] <- subset(bif3.list[[1]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

bif3.list[[2]] <- subset(bif3.list[[2]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)




## Before seurat intergration, filter each sample separately and normalize (using same method for all samples)

## logNormalize

bif3.list[[1]]<- NormalizeData(bif3.list[[1]], normalization.method = "LogNormalize", scale.factor = 10000)

bif3.list[[2]]<- NormalizeData(bif3.list[[2]], normalization.method = "LogNormalize", scale.factor = 10000)


## Find variables


bif3.list[[1]]<- FindVariableFeatures(bif3.list[[1]], selection.method = "vst", nfeatures = 2000)

bif3.list[[2]]<- FindVariableFeatures(bif3.list[[2]], selection.method = "vst", nfeatures = 2000)



# select features that are repeatedly variable across datasets for integration


features <- SelectIntegrationFeatures(object.list = bif3.list)


# find anchors

anchors <- FindIntegrationAnchors(object.list = bif3.list, anchor.features = features)


# Integrate data
# this command creates an 'integrated' data assay

bif3.int <- IntegrateData(anchorset = anchors)


DefaultAssay(bif3.int)<-"integrated"


# Run the standard workflow for visualization and clustering
bif3.int <- ScaleData(bif3.int, verbose = FALSE)
bif3.int <- RunPCA(bif3.int, npcs = 30, verbose = FALSE)


```



```{r}
## Determine the ‘dimensionality’ of the dataset

ElbowPlot(bif3.int, ndims = 40)

## Elbow plot: quantitative approach
## https://hbctraining.github.io/scRNA-seq/lessons/elbow_plot_metric.html


# Determine percent of variation associated with each PC
pct <- bif3.int[["pca"]]@stdev / sum(bif3.int[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1

# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2


# Minimum of the two calculation
pcs <- min(co1, co2)

pcs


```



```{r}
bif3.int <- RunUMAP(bif3.int, reduction = "pca", dims = 1:23) ## Use PC number based on above Elbow plot: quantitative approach

bif3.int <- FindNeighbors(bif3.int, reduction = "pca", dims = 1:23)

bif3.int <- FindClusters(bif3.int, resolution = 0.8)

# Visualization

DimPlot(bif3.int, reduction = "umap", label = TRUE, pt.size = 1)
DimPlot(bif3.int, reduction = "umap", group.by = "orig.ident")

## two plots next to each other 

p1 <- DimPlot(bif3.int, reduction = "umap", group.by = "orig.ident")
p2 <- DimPlot(bif3.int, reduction = "umap", label = TRUE, repel = TRUE)
p1 + p2

### split the UMAPs by samples 

DimPlot(bif3.int, reduction = "umap", split.by = "orig.ident", pt.size = 1)


### group the UMAPs by samples. 

DimPlot(bif3.int, reduction = "umap", group.by = "orig.ident", pt.size = 1)

```
