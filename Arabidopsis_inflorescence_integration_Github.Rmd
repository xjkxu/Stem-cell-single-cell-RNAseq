---
title: "Arabidopsis_inflorescence_integration_Github"
output: html_document
---


Start R (by typing ‘R’ at the command line) and load some R libraries as follows:

## step1 
```{r}

library("rlang")
library("Seurat");
library("sctransform");
library("dplyr");
library("RColorBrewer");
library("ggthemes");
library("ggplot2");
library("cowplot");
library("data.table");
library("xfun");
library("WGCNA")

```


```{r}
## Step 2: find the origial CR path for three whole ear samples

setwd("C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu41_ap1cal")

setwd("C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu42_ap1cal")



## Step 3: Read in the feature-barcode matrices generated by the cellranger pipeline.

memory.limit(size=50000000)

samples=c("xu41","xu42")

data.10x = list()

data.10x[[1]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu41_ap1cal/raw_feature_bc_matrix");

data.10x[[2]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu42_ap1cal/raw_feature_bc_matrix");



## Step 4: Convert each feature-barcode matrix to a Seurat object.

ap1cal.list = list(); # First create an empty list to hold the Seurat objects

ap1cal.list[[1]] = CreateSeuratObject(counts = data.10x[[1]], min.cells=3, min.features=200, project=samples[1]);

ap1cal.list[[1]][["DataSet"]] = samples[1];

ap1cal.list[[2]] = CreateSeuratObject(counts = data.10x[[2]], min.cells=3, min.features=200, project=samples[2]);

ap1cal.list[[2]][["DataSet"]] = samples[2];



## Step 5: Optional, remove the raw data to save space:

rm(data.10x);


### subset each library before merge or integrate


ap1cal.list[[1]] <- subset(ap1cal.list[[1]], subset = nCount_RNA > 1000 & nFeature_RNA > 500 & nCount_RNA < 100000 & nFeature_RNA < 12000)

ap1cal.list[[2]] <- subset(ap1cal.list[[2]], subset = nCount_RNA > 1000 & nFeature_RNA > 500 & nCount_RNA < 100000 & nFeature_RNA < 12000)


```

```{r}
## Step 8-9:for seurat intergration, firstly need to log normalize and then find variables. 
# Filter each sample separately and normalize (using same method for all samples)

## Step 8:logNormalize

ap1cal.list[[1]]<- NormalizeData(ap1cal.list[[1]], normalization.method = "LogNormalize", scale.factor = 10000)

ap1cal.list[[2]]<- NormalizeData(ap1cal.list[[2]], normalization.method = "LogNormalize", scale.factor = 10000)


##Step 9:Find variables


ap1cal.list[[1]]<- FindVariableFeatures(ap1cal.list[[1]], selection.method = "vst", nfeatures = 2000)

ap1cal.list[[2]]<- FindVariableFeatures(ap1cal.list[[2]], selection.method = "vst", nfeatures = 2000)


```



```{r}
features <- SelectIntegrationFeatures(object.list = ap1cal.list)

```



## Step 10:Next Integration of replicates 

# find anchors

```{r}
anchors <- FindIntegrationAnchors(object.list = ap1cal.list, anchor.features = features)
```


# Step 11:Integrate data


```{r}

ap1cal.int <- IntegrateData(anchorset = anchors)

```

```{r}
DefaultAssay(ap1cal.int)<-"integrated"


# Step 13:Run the standard workflow for visualization and clustering
ap1cal.int <- ScaleData(ap1cal.int)
ap1cal.int <- RunPCA(ap1cal.int)


```


```{r}
## Determine the ‘dimensionality’ of the dataset

ElbowPlot(ap1cal.int, ndims = 40)

## Elbow plot: quantitative approach
## https://hbctraining.github.io/scRNA-seq/lessons/elbow_plot_metric.html

# Determine percent of variation associated with each PC
pct <- ap1cal.int[["pca"]]@stdev / sum(ap1cal.int[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1


# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2


# Minimum of the two calculation
pcs <- min(co1, co2)

pcs


```



```{r}
ap1cal.int <- RunUMAP(ap1cal.int, reduction = "pca", dims = 1:21)

ap1cal.int <- FindNeighbors(ap1cal.int, reduction = "pca", dims = 1:21)

ap1cal.int <- FindClusters(ap1cal.int, resolution = 0.78)

```

```{r}
DimPlot(ap1cal.int, reduction = "umap", pt.size = 1, label = TRUE)

```



```{r}
# For exporting table of coexpression value(pearson correlation value) for gene of interest, 

matrix <- ap1cal.int$RNA@data
matrix_mod<-as.matrix(matrix)

## for any gene of interest. Pearson correlation. 
gene<-as.numeric(matrix_mod["AT2G27250",])
correlations<-apply(matrix_mod,1,function(x){cor(gene,x)})
write.table(correlations, file = "ap1cal.int.Dec.CLV3_Pearson_correlation.txt")
```


```{r}

## FindAllMarkers

DefaultAssay(ap1cal.int)<-"RNA"


all.markers <- FindAllMarkers(object = ap1cal.int, logfc.threshold = 0.25)

write.table(all.markers, file=sprintf("ap1cal.int_FindAllMarkers_logfc0.25.xls"), quote=FALSE, sep="\t", row.names=FALSE);

```

