---
title: "B73_ear_tip_integration_&_Slingshot_Github_Figure1A-1C_S2C-S2L"

## Load all packages
```{r}
## for Seurat integration 

library("rlang")
library("Seurat");
library("sctransform");
library("dplyr");
library("RColorBrewer");
library("ggthemes");
library("ggplot2");
library("cowplot");
library("data.table");
library("scales")


## for slingshot 

library(tidyverse)
library(slingshot)
library(Seurat)
library(tradeSeq)
library(S4Vectors)
library(SingleCellExperiment)
library(BUSpaRse)
library(tidymodels)
library(scales)
library(viridis)
library(Matrix)


```


## Set up Seurat object
```{r}

## Read in the feature-barcode matrices generated by the cellranger pipeline.

memory.limit(size=50000000)

samples=c("xu16","xu19","xu29","xu32")

data.10x = list()

data.10x[[1]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu16_2017_cus_CR310_S150_L151/raw_feature_bc_matrix");

data.10x[[2]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu19_2017_cus_CR310_S150_L151/raw_feature_bc_matrix");

data.10x[[3]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu29_B73_tip/raw_feature_bc_matrix");

data.10x[[4]] <- Read10X(data.dir = "C:/Users/Xiaosa Xu/Desktop/Seurat_2020/xu32_B73_tip/raw_feature_bc_matrix");


## Convert each feature-barcode matrix to a Seurat object.

B73_ear_tip.list = list(); 

B73_ear_tip.list[[1]] = CreateSeuratObject(counts = data.10x[[1]], min.cells=3, min.features=200, project=samples[1]);

B73_ear_tip.list[[1]][["DataSet"]] = samples[1];

B73_ear_tip.list[[2]] = CreateSeuratObject(counts = data.10x[[2]], min.cells=3, min.features=200, project=samples[2]);

B73_ear_tip.list[[2]][["DataSet"]] = samples[2];

B73_ear_tip.list[[3]] = CreateSeuratObject(counts = data.10x[[3]], min.cells=3, min.features=200, project=samples[3]);

B73_ear_tip.list[[3]][["DataSet"]] = samples[3];

B73_ear_tip.list[[4]] = CreateSeuratObject(counts = data.10x[[4]], min.cells=3, min.features=200, project=samples[4]);

B73_ear_tip.list[[4]][["DataSet"]] = samples[4];


## Optional, remove the raw data to save space:

rm(data.10x);


### Subset each library to filter low quality cells


B73_ear_tip.list[[1]] <- subset(B73_ear_tip.list[[1]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

B73_ear_tip.list[[2]] <- subset(B73_ear_tip.list[[2]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

B73_ear_tip.list[[3]] <- subset(B73_ear_tip.list[[3]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)

B73_ear_tip.list[[4]] <- subset(B73_ear_tip.list[[4]], subset = nCount_RNA > 5000 & nFeature_RNA > 1000 & nCount_RNA < 150000 & nFeature_RNA < 15000)


## logNormalize

B73_ear_tip.list[[1]]<- NormalizeData(B73_ear_tip.list[[1]], normalization.method = "LogNormalize", scale.factor = 10000)

B73_ear_tip.list[[2]]<- NormalizeData(B73_ear_tip.list[[2]], normalization.method = "LogNormalize", scale.factor = 10000)

B73_ear_tip.list[[3]]<- NormalizeData(B73_ear_tip.list[[3]], normalization.method = "LogNormalize", scale.factor = 10000)

B73_ear_tip.list[[4]]<- NormalizeData(B73_ear_tip.list[[4]], normalization.method = "LogNormalize", scale.factor = 10000)


##Find variables


B73_ear_tip.list[[1]]<- FindVariableFeatures(B73_ear_tip.list[[1]], selection.method = "vst", nfeatures = 2000)

B73_ear_tip.list[[2]]<- FindVariableFeatures(B73_ear_tip.list[[2]], selection.method = "vst", nfeatures = 2000)

B73_ear_tip.list[[3]]<- FindVariableFeatures(B73_ear_tip.list[[3]], selection.method = "vst", nfeatures = 2000)

B73_ear_tip.list[[4]]<- FindVariableFeatures(B73_ear_tip.list[[4]], selection.method = "vst", nfeatures = 2000)


# select features that are repeatedly variable across datasets for integration


features <- SelectIntegrationFeatures(object.list = B73_ear_tip.list)


# find anchors

anchors <- FindIntegrationAnchors(object.list = B73_ear_tip.list, anchor.features = features)


# Integrate data

B73_ear_tip.int <- IntegrateData(anchorset = anchors)


DefaultAssay(B73_ear_tip.int)<-"integrated"


# Run the standard workflow for visualization and clustering
B73_ear_tip.int <- ScaleData(B73_ear_tip.int, verbose = FALSE)
B73_ear_tip.int <- RunPCA(B73_ear_tip.int, npcs = 30, verbose = FALSE)


```



```{r}
## Determine the ‘dimensionality’ of the dataset

ElbowPlot(B73_ear_tip.int, ndims = 40)

## Elbow plot: quantitative approach
## https://hbctraining.github.io/scRNA-seq/lessons/elbow_plot_metric.html

## We will start by calculating the first metric:
# Determine percent of variation associated with each PC
pct <- B73_ear_tip.int[["pca"]]@stdev / sum(B73_ear_tip.int[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1

# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2

# Minimum of the two calculation
pcs <- min(co1, co2)

pcs


```



```{r}
B73_ear_tip.int <- RunUMAP(B73_ear_tip.int, reduction = "pca", dims = 1:19) ## Use the PC number based on above Elbow plot: quantitative approach

B73_ear_tip.int <- FindNeighbors(B73_ear_tip.int, reduction = "pca", dims = 1:19)

B73_ear_tip.int <- FindClusters(B73_ear_tip.int, resolution = 0.85)

# Visualization

DimPlot(B73_ear_tip.int, reduction = "umap", label = TRUE, pt.size = 1)
DimPlot(B73_ear_tip.int, reduction = "umap", group.by = "orig.ident")

## two plots next to each other 

p1 <- DimPlot(B73_ear_tip.int, reduction = "umap", group.by = "orig.ident")
p2 <- DimPlot(B73_ear_tip.int, reduction = "umap", label = TRUE, repel = TRUE)
p1 + p2

### split the UMAPs by samples 

DimPlot(B73_ear_tip.int, reduction = "umap", split.by = "orig.ident", pt.size = 1)


### group the UMAPs by samples. 

DimPlot(B73_ear_tip.int, reduction = "umap", group.by = "orig.ident", pt.size = 1)

```


```{r}
## Remove cluster 3 with very low UMI (dead cells)

B73_ear_tip.int_remove_dead <- subset(B73_ear_tip.int, idents = 2, invert = TRUE)

DimPlot(B73_ear_tip.int_remove_dead, reduction = "umap", label = TRUE, pt.size = 1)


### split the integrated object to re-normalize and process

B73_ear_tip.list <- SplitObject(B73_ear_tip.int_remove_dead, split.by = "orig.ident")

B73_ear_tip.list


## need to set RNA assay before normalization and processing 

DefaultAssay(B73_ear_tip.list[[1]]) <- "RNA"
DefaultAssay(B73_ear_tip.list[[2]]) <- "RNA"
DefaultAssay(B73_ear_tip.list[[3]]) <- "RNA"
DefaultAssay(B73_ear_tip.list[[4]]) <- "RNA"



## logNormalize

B73_ear_tip.list[[1]]<- NormalizeData(B73_ear_tip.list[[1]], normalization.method = "LogNormalize", scale.factor = 10000)

B73_ear_tip.list[[2]]<- NormalizeData(B73_ear_tip.list[[2]], normalization.method = "LogNormalize", scale.factor = 10000)

B73_ear_tip.list[[3]]<- NormalizeData(B73_ear_tip.list[[3]], normalization.method = "LogNormalize", scale.factor = 10000)

B73_ear_tip.list[[4]]<- NormalizeData(B73_ear_tip.list[[4]], normalization.method = "LogNormalize", scale.factor = 10000)


## Find variables


B73_ear_tip.list[[1]]<- FindVariableFeatures(B73_ear_tip.list[[1]], selection.method = "vst", nfeatures = 2000)

B73_ear_tip.list[[2]]<- FindVariableFeatures(B73_ear_tip.list[[2]], selection.method = "vst", nfeatures = 2000)

B73_ear_tip.list[[3]]<- FindVariableFeatures(B73_ear_tip.list[[3]], selection.method = "vst", nfeatures = 2000)

B73_ear_tip.list[[4]]<- FindVariableFeatures(B73_ear_tip.list[[4]], selection.method = "vst", nfeatures = 2000)


# select features that are repeatedly variable across datasets for integration


features <- SelectIntegrationFeatures(object.list = B73_ear_tip.list)

# find anchors

anchors <- FindIntegrationAnchors(object.list = B73_ear_tip.list, anchor.features = features)


# Integrate data
# this command creates an 'integrated' data assay

B73_ear_tip.int <- IntegrateData(anchorset = anchors)


DefaultAssay(B73_ear_tip.int)<-"integrated"


# Run the standard workflow for visualization and clustering
B73_ear_tip.int <- ScaleData(B73_ear_tip.int, verbose = FALSE)
B73_ear_tip.int <- RunPCA(B73_ear_tip.int, npcs = 30, verbose = FALSE)


```



```{r}
## Optional step: Determine the ‘dimensionality’ of the dataset

ElbowPlot(B73_ear_tip.int, ndims = 40)

## Elbow plot: quantitative approach
## https://hbctraining.github.io/scRNA-seq/lessons/elbow_plot_metric.html

# Determine percent of variation associated with each PC
pct <- B73_ear_tip.int[["pca"]]@stdev / sum(B73_ear_tip.int[["pca"]]@stdev) * 100

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

co1

# Determine the difference between variation of PC and subsequent PC
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

# last point where change of % of variation is more than 0.1%.
co2

# Minimum of the two calculation
pcs <- min(co1, co2)

pcs


```



```{r}
B73_ear_tip.int <- RunUMAP(B73_ear_tip.int, reduction = "pca", dims = 1:24) ## Use the PC number based on above Elbow plot: quantitative approach

B73_ear_tip.int <- FindNeighbors(B73_ear_tip.int, reduction = "pca", dims = 1:24)

B73_ear_tip.int <- FindClusters(B73_ear_tip.int, resolution = 0.65)

# Visualization

DimPlot(B73_ear_tip.int, reduction = "umap", label = TRUE, pt.size = 1)

DimPlot(B73_ear_tip.int, reduction = "umap", group.by = "orig.ident")

## two plots next to each other 

p1 <- DimPlot(B73_ear_tip.int, reduction = "umap", group.by = "orig.ident")
p2 <- DimPlot(B73_ear_tip.int, reduction = "umap", label = TRUE, repel = TRUE)
p1 + p2

### split the UMAPs by samples 

DimPlot(B73_ear_tip.int, reduction = "umap", split.by = "orig.ident", pt.size = 1)


### group the UMAPs by samples. 

DimPlot(B73_ear_tip.int, reduction = "umap", group.by = "orig.ident", pt.size = 1)

```


```{r}
## Prepare Subcluster6 by assigning graph.name="mygraph"

##next run UMAP

DefaultAssay(B73_ear_tip.int)<-"integrated"

B73_ear_tip.int.subcluster <- FindNeighbors(B73_ear_tip.int, graph.name= "mygraph", dims = 1:18)

B73_ear_tip.int.subcluster <- FindClusters(B73_ear_tip.int.subcluster, graph.name = "mygraph", resolution = 0.8)

B73_ear_tip.int.subcluster <- RunUMAP(B73_ear_tip.int.subcluster, reduction = "pca", dims = 1:30)


DimPlot(B73_ear_tip.int.subcluster, reduction = "umap", label = TRUE, repel = TRUE, pt.size = 1, label.size = 10)


```


```{r}
### subcluster cluster
B73_ear_tip.int.subcluster6 <- FindSubCluster(B73_ear_tip.int.subcluster, "6", "mygraph", subcluster.name = "subcluster6",  resolution = 0.2, algorithm = 1)


## Plot the sub-cluster 

DimPlot(B73_ear_tip.int.subcluster6, reduction = "umap", group.by = "subcluster6", label = TRUE, label.size = 10, pt.size = 1)

```

```{r}
## transfer subcluster6 identity as active identity 

Idents(B73_ear_tip.int.subcluster6) <- "subcluster6"

## check if transfer is completed. 
DimPlot(B73_ear_tip.int.subcluster6, reduction = "umap", label = TRUE, label.size = 10, pt.size = 1)

```


```{r}

# Display unique cluster labels
unique(Idents(B73_ear_tip.int.subcluster6))


## change cluster labels for 6_0 and 6_1 to be 6 and 9 respectively.
## meanwhile, merge cell cycle cluster 7, 9, and 13 to be 7
## meanwhile, change cluster label 14 to be 13


new.cluster.ids <- c("13", "6", "0", "1", "3", "7", "4", "7", "8", "2", "5", "11", "7","12","10","9")

names(new.cluster.ids) <- levels(B73_ear_tip.int.subcluster6)

B73_ear_tip.int.subcluster6.rename <- RenameIdents(B73_ear_tip.int.subcluster6, new.cluster.ids)

DimPlot(B73_ear_tip.int.subcluster6.rename, reduction = "umap", label = TRUE, label.size = 8, pt.size = 1)


saveRDS(B73_ear_tip.int.subcluster6.rename, file = "B73_ear_tip.int.subcluster6.rename.rds")


```



```{r}
# For exporting table of coexpression value(pearson correlation value) for gene of interest, 

matrix <- B73_ear_tip.int.subcluster6.rename$RNA@data
matrix_mod<-as.matrix(matrix)

## for any gene of interest. pearson correlation 
gene<-as.numeric(matrix_mod["GRMZM2G372364",])
correlations<-apply(matrix_mod,1,function(x){cor(gene,x)})
write.table(correlations, file = "B73_ear_tip.int.subcluster6.rename_CLE7_Pearson_correlation.txt")

```


```{r}
## FindAllMarkers

DefaultAssay(B73_ear_tip.int.subcluster6.rename)<-"RNA"

all.markers <- FindAllMarkers(object = B73_ear_tip.int.subcluster6.rename)

write.table(all.markers, file=sprintf("B73_ear_tip.int.subcluster6.rename_FindAllMarkers.xls"), quote=FALSE, sep="\t", row.names=FALSE);

```




## subcluster IM and SPM to run slingshot trajectory. 

```{r}

## IM use the original scale 

IM <- subset(B73.tip, idents = c(1, 3, 4))



IM.oriscale <- RunUMAP(IM, reduction = "pca", dims = 1:30) ## Use default 30

# Visualization

DimPlot(IM.oriscale, reduction = "umap", label = TRUE, pt.size = 1)

DimPlot(IM.oriscale, reduction = "umap", group.by = "subcluster6", pt.size = 1, label = TRUE, )


# Slingshot
# https://github.com/kstreet13/slingshot/issues/105

sdsIM.ori <- slingshot(Embeddings(IM.oriscale, "umap"), clusterLabels = IM.oriscale$subcluster6,
start.clus = 3, end.clus = c("1","4"), stretch = 0)

sdsIM.ori

## Unfortunately, slingshot does not natively support ggplot2. So this is a function that assigns colors to each cell in base R graphics.
## https://bustools.github.io/BUS_notebooks_R/slingshot.html#slingshot
## https://bustools.github.io/BUS_notebooks_R/slingshot.html#trajectory_inference

cell_pal <- function(cell_vars, pal_fun,...) {
  if (is.numeric(cell_vars)) {
    pal <- pal_fun(100, ...)
    return(pal[cut(cell_vars, breaks = 100)])
  } else {
    categories <- sort(unique(cell_vars))
    pal <- setNames(pal_fun(length(categories), ...), categories)
    return(pal[cell_vars])
  }
}



cell_colors_clust <- cell_pal(IM.oriscale$subcluster6, hue_pal()) 

plot(reducedDim(sdsIM.ori), col = cell_colors_clust, pch = 16, cex = 1)

lines(sdsIM.ori, lwd = 2, type = 'c', col = 'black') ## make sure type = 'c' which is the curve. 
lines(sdsIM.ori, lwd = 2, type = 'lineage', col = 'black') ## make sure type = 'c' which is the curve.


## Plot pseudotime for gene of interest. 

exp<-GetAssayData(IM.ori, slot = "data")

plotGenePseudotime(sdsIM.ori, "GRMZM2G372364", exp ) ## plot gene of interest one at a time for each lineages

plotGenePseudotime(sdsIM.ori, "GRMZM2G372364", col = cell_colors_clust, exp ) ## plot gene of interest one at a time for each lineages


## Which cells are in which lineage? Here we plot the pseudotime values for each lineage.


### curve
nc <- 3

pt <- slingPseudotime(sdsIM.ori)

nms <- colnames(pt)

nr <- ceiling(length(nms)/nc)

pal <- viridis(100, end = 0.95)

par(mfrow = c(nr, nc))

for (i in nms) {
  colors <- pal[cut(pt[,i], breaks = 100)]
  plot(reducedDim(sdsIM.ori), col = colors, pch = 16, cex = 1, main = i)
  lines(sdsIM.ori, lwd = 2, col = 'black', type = 'c')
}



#### lineage
nc <- 3

pt <- slingPseudotime(sdsIM.ori)

nms <- colnames(pt)

nr <- ceiling(length(nms)/nc)

pal <- viridis(100, end = 0.95)

par(mfrow = c(nr, nc))

for (i in nms) {
  colors <- pal[cut(pt[,i], breaks = 100)]
  plot(reducedDim(sdsIM.ori), col = colors, pch = 16, cex = 1, main = i)
  lines(sdsIM.ori, lwd = 2, col = 'black', type = 'lineage')
}

```





```{r}

## subcluster SPM to run slingshot trajectory. 

SPM.ori.scale <- subset(B73.tip, idents = c(5, 6, 12, 14))


SPM.ori.scale <- RunUMAP(SPM.ori.scale, reduction = "pca", dims = 1:30) ## Use default 30, or change the PC number based on above Elbow plot: quantitative approach

# Visualization

DimPlot(SPM.ori.scale, reduction = "umap", label = TRUE, pt.size = 1)

DimPlot(SPM.ori.scale, reduction = "umap", group.by = "subcluster6", pt.size = 1, label = TRUE)


# Slingshot
# https://github.com/kstreet13/slingshot/issues/105

sdsSPM.ori <- slingshot(Embeddings(SPM.ori.scale, "umap"), clusterLabels = SPM.ori.scale$subcluster6,
start.clus = 5, end.clus = c("6_0","6_1","12","14"), stretch = 0)

sdsSPM.ori

## Unfortunately, slingshot does not natively support ggplot2. So this is a function that assigns colors to each cell in base R graphics.
## https://bustools.github.io/BUS_notebooks_R/slingshot.html#slingshot
## https://bustools.github.io/BUS_notebooks_R/slingshot.html#trajectory_inference


cell_pal <- function(cell_vars, pal_fun,...) {
  if (is.numeric(cell_vars)) {
    pal <- pal_fun(100, ...)
    return(pal[cut(cell_vars, breaks = 100)])
  } else {
    categories <- sort(unique(cell_vars))
    pal <- setNames(pal_fun(length(categories), ...), categories)
    return(pal[cell_vars])
  }
}



cell_colors_clust <- cell_pal(SPM.ori.scale$subcluster6, hue_pal()) 

plot(reducedDim(sdsSPM.ori), col = cell_colors_clust, pch = 16, cex = 1)

lines(sdsSPM.ori, lwd = 2, type = 'c', col = 'black') ## make sure type = 'c' which is the curve. 
lines(sdsSPM.ori, lwd = 2, type = 'lineage', col = 'black') ## make sure type = 'c' which is the curve.

## Plot pseudotime for gene of interest. 

DefaultAssay(SPM.ori.scale) <- "RNA"

exp<-GetAssayData(SPM.ori.scale, slot = "data")

plotGenePseudotime(sdsSPM.ori, "GRMZM2G372364", exp ) ## plot gene of interest one at a time for each lineages

plotGenePseudotime(sdsSPM.ori, "GRMZM2G372364", col = cell_colors_clust, exp ) ## plot gene of interest one at a time for each lineages


## Which cells are in which lineage? Here we plot the pseudotime values for each lineage.


## curve
nc <- 3

pt <- slingPseudotime(sdsSPM.ori)

nms <- colnames(pt)

nr <- ceiling(length(nms)/nc)

pal <- viridis(100, end = 0.95)

par(mfrow = c(nr, nc))

for (i in nms) {
  colors <- pal[cut(pt[,i], breaks = 100)]
  plot(reducedDim(sdsSPM.ori), col = colors, pch = 16, cex = 1, main = i)
  lines(sdsSPM.ori, lwd = 2, col = 'black', type = 'c')
}


## lineage
nc <- 3

pt <- slingPseudotime(sdsSPM.ori)

nms <- colnames(pt)

nr <- ceiling(length(nms)/nc)

pal <- viridis(100, end = 0.95)

par(mfrow = c(nr, nc))

for (i in nms) {
  colors <- pal[cut(pt[,i], breaks = 100)]
  plot(reducedDim(sdsSPM.ori), col = colors, pch = 16, cex = 1, main = i)
  lines(sdsSPM.ori, lwd = 2, col = 'black', type = 'lineage')
}


```

